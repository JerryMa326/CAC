<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Face Tracking with RGB Analysis</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 900px;
            width: 100%;
        }

        h1 {
            text-align: center;
            color: #333;
            margin-bottom: 10px;
            font-size: 2em;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 0.95em;
        }

        .video-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
            background: #000;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }

        #video, #canvas {
            width: 100%;
            max-width: 640px;
            height: auto;
            display: block;
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 50%;
            transform: translateX(-50%);
        }

        .controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }
        
        .slider-container {
            width: 100%;
            max-width: 400px;
            margin: 0 auto 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .color-picker-container {
            width: 100%;
            max-width: 400px;
            margin: 0 auto 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 10px;
        }
        
        .picker-wrapper {
            display: flex;
            align-items: center;
            gap: 20px;
            margin-top: 15px;
        }
        
        #colorWheel {
            cursor: crosshair;
            border-radius: 50%;
            box-shadow: 0 4px 10px rgba(0,0,0,0.2);
        }
        
        .brightness-slider-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 5px;
        }
        
        .brightness-slider-container label {
            font-size: 12px;
            color: #666;
            font-weight: 600;
        }
        
        #brightnessValue {
            text-align: center;
            font-size: 12px;
            color: #666;
        }
        
        .cutoff-preview {
            width: 60px;
            height: 60px;
            border: 3px solid white;
            border-radius: 10px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            background: rgb(128, 128, 128);
        }
        
        .color-value {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 2px 10px;
            border-radius: 15px;
            font-weight: 600;
            font-size: 12px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            font-size: 14px;
            color: #333;
        }
        
        .slider-value {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            padding: 2px 10px;
            border-radius: 15px;
            font-weight: 600;
            min-width: 45px;
            text-align: center;
        }
        
        input[type="range"] {
            width: 100%;
            height: 8px;
            border-radius: 5px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }
        
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }
        
        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 15px rgba(102, 126, 234, 0.5);
        }

        button {
            padding: 12px 30px;
            font-size: 16px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        #startBtn {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
        }

        #startBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }

        #stopBtn {
            background: #ff6b6b;
            color: white;
        }

        #stopBtn:hover:not(:disabled) {
            background: #ff5252;
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(255, 107, 107, 0.4);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .status {
            text-align: center;
            margin-top: 20px;
            padding: 15px;
            border-radius: 10px;
            background: #f0f0f0;
            color: #666;
            font-size: 14px;
            min-height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-right: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .face-box {
            position: absolute;
            border: 3px solid #00ff00;
            pointer-events: none;
        }

        .rgb-label {
            position: absolute;
            top: -30px;
            left: 0;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            white-space: nowrap;
        }

        @media (max-width: 640px) {
            .container {
                padding: 20px;
            }
            
            h1 {
                font-size: 1.5em;
            }
            
            button {
                padding: 10px 20px;
                font-size: 14px;
            }
            
            .picker-wrapper {
                flex-direction: column;
                align-items: center;
            }
            
            .brightness-slider-container {
                width: 100%;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Face Tracking with RGB Analysis</h1>
        <p class="subtitle">Real-time face detection with RGB comparison ‚Ä¢ Red box = darker than cutoff ‚Ä¢ Green box = lighter</p>
        
        <div class="video-container">
            <video id="video" autoplay muted></video>
            <canvas id="canvas"></canvas>
        </div>
        
        <div class="controls">
            <button id="startBtn">Start Camera</button>
            <button id="stopBtn" disabled>Stop Camera</button>
        </div>
        
        <div class="slider-container">
            <div class="slider-label">
                <span>Detection Sensitivity</span>
                <span class="slider-value" id="sensitivityValue">50%</span>
            </div>
            <input type="range" id="sensitivitySlider" min="5" max="100" value="50" step="5">
        </div>
        
        <div class="color-picker-container">
            <div class="slider-label">
                <span>RGB Cutoff Threshold</span>
                <span class="color-value" id="colorValue">RGB(128, 128, 128)</span>
            </div>
            <div class="picker-wrapper">
                <canvas id="colorWheel" width="200" height="200"></canvas>
                <div class="brightness-slider-container">
                    <label>Brightness</label>
                    <input type="range" id="brightnessSlider" min="0" max="255" value="128">
                    <span id="brightnessValue">128</span>
                </div>
                <div style="display: flex; flex-direction: column; align-items: center; gap: 5px;">
                    <div class="cutoff-preview" id="cutoffPreview"></div>
                    <small style="color: #666; font-size: 11px;">Cutoff Color</small>
                </div>
            </div>
        </div>
        
        <div class="status" id="status">
            Click "Start Camera" to begin face tracking
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/face-api.js@0.22.2/dist/face-api.min.js"></script>
    <script>
        const video = document.getElementById('video');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');
        const sensitivitySlider = document.getElementById('sensitivitySlider');
        const sensitivityValue = document.getElementById('sensitivityValue');
        const colorWheel = document.getElementById('colorWheel');
        const colorWheelCtx = colorWheel.getContext('2d');
        const brightnessSlider = document.getElementById('brightnessSlider');
        const brightnessValue = document.getElementById('brightnessValue');
        const colorValue = document.getElementById('colorValue');
        const cutoffPreview = document.getElementById('cutoffPreview');
        
        let isDetecting = false;
        let stream = null;
        let modelLoaded = false;
        let cutoffRGB = { r: 128, g: 128, b: 128 };
        let selectedHue = 0;
        let selectedSaturation = 0;
        
        // Update sensitivity display
        sensitivitySlider.addEventListener('input', (e) => {
            sensitivityValue.textContent = `${e.target.value}%`;
        });
        
        // Initialize color wheel
        function drawColorWheel() {
            const centerX = colorWheel.width / 2;
            const centerY = colorWheel.height / 2;
            const radius = Math.min(centerX, centerY) - 5;
            
            // Clear canvas
            colorWheelCtx.clearRect(0, 0, colorWheel.width, colorWheel.height);
            
            // Draw color wheel
            for (let angle = 0; angle < 360; angle += 1) {
                const startAngle = (angle - 1) * Math.PI / 180;
                const endAngle = angle * Math.PI / 180;
                
                for (let r = 0; r < radius; r += 1) {
                    const saturation = r / radius;
                    const hue = angle;
                    const rgb = hsvToRgb(hue, saturation, brightnessSlider.value / 255);
                    
                    colorWheelCtx.beginPath();
                    colorWheelCtx.arc(centerX, centerY, r, startAngle, endAngle);
                    colorWheelCtx.strokeStyle = `rgb(${rgb.r}, ${rgb.g}, ${rgb.b})`;
                    colorWheelCtx.lineWidth = 2;
                    colorWheelCtx.stroke();
                }
            }
            
            // Draw selection indicator
            const selectionRadius = selectedSaturation * radius;
            const selectionAngle = selectedHue * Math.PI / 180;
            const selectionX = centerX + selectionRadius * Math.cos(selectionAngle);
            const selectionY = centerY + selectionRadius * Math.sin(selectionAngle);
            
            colorWheelCtx.strokeStyle = 'white';
            colorWheelCtx.lineWidth = 3;
            colorWheelCtx.beginPath();
            colorWheelCtx.arc(selectionX, selectionY, 5, 0, 2 * Math.PI);
            colorWheelCtx.stroke();
            
            colorWheelCtx.strokeStyle = 'black';
            colorWheelCtx.lineWidth = 1;
            colorWheelCtx.beginPath();
            colorWheelCtx.arc(selectionX, selectionY, 5, 0, 2 * Math.PI);
            colorWheelCtx.stroke();
        }
        
        // HSV to RGB conversion
        function hsvToRgb(h, s, v) {
            h = h / 360;
            let r, g, b;
            const i = Math.floor(h * 6);
            const f = h * 6 - i;
            const p = v * (1 - s);
            const q = v * (1 - f * s);
            const t = v * (1 - (1 - f) * s);
            
            switch (i % 6) {
                case 0: r = v, g = t, b = p; break;
                case 1: r = q, g = v, b = p; break;
                case 2: r = p, g = v, b = t; break;
                case 3: r = p, g = q, b = v; break;
                case 4: r = t, g = p, b = v; break;
                case 5: r = v, g = p, b = q; break;
            }
            
            return {
                r: Math.round(r * 255),
                g: Math.round(g * 255),
                b: Math.round(b * 255)
            };
        }
        
        // Update cutoff color
        function updateCutoffColor() {
            cutoffRGB = hsvToRgb(selectedHue, selectedSaturation, brightnessSlider.value / 255);
            cutoffPreview.style.background = `rgb(${cutoffRGB.r}, ${cutoffRGB.g}, ${cutoffRGB.b})`;
            colorValue.textContent = `RGB(${cutoffRGB.r}, ${cutoffRGB.g}, ${cutoffRGB.b})`;
            drawColorWheel();
        }
        
        // Color wheel interaction handlers
        let isDragging = false;
        
        function handleColorWheelInteraction(e) {
            const rect = colorWheel.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const centerX = colorWheel.width / 2;
            const centerY = colorWheel.height / 2;
            const radius = Math.min(centerX, centerY) - 5;
            
            const dx = x - centerX;
            const dy = y - centerY;
            const distance = Math.sqrt(dx * dx + dy * dy);
            
            if (distance <= radius) {
                selectedSaturation = distance / radius;
                selectedHue = (Math.atan2(dy, dx) * 180 / Math.PI + 360) % 360;
                updateCutoffColor();
            }
        }
        
        colorWheel.addEventListener('mousedown', (e) => {
            isDragging = true;
            handleColorWheelInteraction(e);
        });
        
        colorWheel.addEventListener('mousemove', (e) => {
            if (isDragging) {
                handleColorWheelInteraction(e);
            }
        });
        
        colorWheel.addEventListener('mouseup', () => {
            isDragging = false;
        });
        
        colorWheel.addEventListener('mouseleave', () => {
            isDragging = false;
        });
        
        colorWheel.addEventListener('click', handleColorWheelInteraction);
        
        // Brightness slider handler
        brightnessSlider.addEventListener('input', (e) => {
            brightnessValue.textContent = e.target.value;
            updateCutoffColor();
        });
        
        // Calculate brightness of RGB
        function getRGBBrightness(rgb) {
            // Using perceived brightness formula
            return (rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114);
        }
        
        // Initialize color wheel on load
        drawColorWheel();
        updateCutoffColor();

        // Load face detection models
        async function loadModels() {
            status.innerHTML = '<span class="loading"></span>Loading face detection models...';
            
            // Try multiple CDN sources
            const MODEL_URLS = [
                'https://justadudewhohacks.github.io/face-api.js/models',
                'https://raw.githubusercontent.com/justadudewhohacks/face-api.js/master/weights'
            ];
            
            let loaded = false;
            for (const url of MODEL_URLS) {
                try {
                    console.log(`üì¶ Attempting to load models from: ${url}`);
                    await faceapi.nets.tinyFaceDetector.loadFromUri(url);
                    console.log('‚úÖ TinyFaceDetector model loaded successfully!');
                    
                    // Try to load SSD Mobilenet as well, but don't fail if it doesn't work
                    try {
                        await faceapi.nets.ssdMobilenetv1.loadFromUri(url);
                        console.log('‚úÖ SSD Mobilenet model loaded successfully!');
                    } catch (e) {
                        console.log('‚ö†Ô∏è SSD Mobilenet not available, using TinyFaceDetector only');
                    }
                    
                    loaded = true;
                    modelLoaded = true;
                    break;
                } catch (error) {
                    console.log(`‚ö†Ô∏è Failed to load from ${url}, trying next...`);
                }
            }
            
            if (loaded) {
                status.textContent = 'Models loaded successfully! Ready to start.';
                console.log('üéâ Application ready! Click "Start Camera" to begin.');
                console.log('üí° Tips for better detection:');
                console.log('  - Ensure good lighting on your face');
                console.log('  - Face the camera directly');
                console.log('  - Move slider to 100% for maximum sensitivity');
                return true;
            } else {
                status.textContent = 'Error loading models. Please refresh the page.';
                console.error('‚ùå Could not load models from any source');
                return false;
            }
        }

        // Start camera and face detection
        async function startCamera() {
            if (!modelLoaded) {
                status.textContent = 'Please wait for models to load...';
                return;
            }
            
            try {
                status.innerHTML = '<span class="loading"></span>Accessing camera...';
                console.log('üì∏ Starting camera...');
                
                stream = await navigator.mediaDevices.getUserMedia({ 
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    } 
                });
                
                video.srcObject = stream;
                console.log('‚úÖ Camera stream obtained');
                
                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    console.log(`üìê Video dimensions: ${video.videoWidth}x${video.videoHeight}`);
                    status.textContent = 'Camera started! Detecting faces...';
                    isDetecting = true;
                    console.log('üöÄ Starting face detection...');
                    detectFaces();
                });
                
                startBtn.disabled = true;
                stopBtn.disabled = false;
                
            } catch (error) {
                status.textContent = 'Error accessing camera. Please check permissions.';
                console.error('‚ùå Error accessing camera:', error);
            }
        }

        // Stop camera and detection
        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                video.srcObject = null;
                stream = null;
            }
            
            isDetecting = false;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            startBtn.disabled = false;
            stopBtn.disabled = true;
            status.textContent = 'Camera stopped. Click "Start Camera" to resume.';
        }

        // Calculate average RGB of a region
        function getAverageRGB(imageData, x, y, width, height) {
            const data = imageData.data;
            let r = 0, g = 0, b = 0;
            let count = 0;
            
            // Ensure boundaries are within canvas
            const startX = Math.max(0, Math.floor(x));
            const startY = Math.max(0, Math.floor(y));
            const endX = Math.min(canvas.width, Math.floor(x + width));
            const endY = Math.min(canvas.height, Math.floor(y + height));
            
            for (let py = startY; py < endY; py++) {
                for (let px = startX; px < endX; px++) {
                    const idx = (py * canvas.width + px) * 4;
                    r += data[idx];
                    g += data[idx + 1];
                    b += data[idx + 2];
                    count++;
                }
            }
            
            if (count === 0) count = 1;
            
            return {
                r: Math.round(r / count),
                g: Math.round(g / count),
                b: Math.round(b / count)
            };
        }

        // Detect faces continuously
        async function detectFaces() {
            if (!isDetecting || !modelLoaded) return;
            
            try {
                // Get sensitivity from slider (invert it for threshold - higher sensitivity = lower threshold)
                const sensitivity = parseInt(sensitivitySlider.value);
                // At 100% sensitivity, threshold is essentially 0, at 50% it's 0.25
                const threshold = sensitivity === 100 ? 0.0001 : Math.max(0.01, (100 - sensitivity) / 100 * 0.5);
                
                console.log(`üîç Attempting detection with sensitivity: ${sensitivity}%, threshold: ${threshold.toFixed(4)}`);
                
                let detections = [];
                
                // Try SSD Mobilenet first if available
                if (faceapi.nets.ssdMobilenetv1.isLoaded) {
                    try {
                        detections = await faceapi.detectAllFaces(
                            video, 
                            new faceapi.SsdMobilenetv1Options({
                                minConfidence: threshold
                            })
                        );
                    } catch (e) {
                        console.log('SSD Mobilenet detection failed, falling back to TinyFaceDetector');
                    }
                }
                
                // Use TinyFaceDetector if no faces found or SSD not available
                if (detections.length === 0) {
                    // Use smaller input size for higher sensitivity
                    const inputSize = sensitivity >= 95 ? 128 : sensitivity >= 80 ? 160 : 224;
                    detections = await faceapi.detectAllFaces(
                        video, 
                        new faceapi.TinyFaceDetectorOptions({
                            inputSize: inputSize,
                            scoreThreshold: threshold
                        })
                    );
                    console.log(`  Using TinyFaceDetector with inputSize: ${inputSize}`);
                }
                
                // If still no detections and at max sensitivity, try with different options
                if (detections.length === 0 && sensitivity === 100) {
                    console.log('  Trying alternative detection options...');
                    for (let size of [96, 128, 160, 224, 320, 416]) {
                        detections = await faceapi.detectAllFaces(
                            video, 
                            new faceapi.TinyFaceDetectorOptions({
                                inputSize: size,
                                scoreThreshold: 0.0001
                            })
                        );
                        if (detections.length > 0) {
                            console.log(`  ‚úÖ Success with inputSize: ${size}`);
                            break;
                        }
                    }
                }
                
                if (detections.length > 0) {
                    console.log(`‚úÖ FACES DETECTED: ${detections.length} face(s) found!`);
                    detections.forEach((d, i) => {
                        console.log(`  Face ${i+1}: Confidence ${(d.score * 100).toFixed(1)}%, Box: x=${Math.round(d.box.x)}, y=${Math.round(d.box.y)}, w=${Math.round(d.box.width)}, h=${Math.round(d.box.height)}`);
                    });
                }
                
                // Clear canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Draw video frame to canvas (hidden) to get pixel data
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = canvas.width;
                tempCanvas.height = canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(video, 0, 0, canvas.width, canvas.height);
                const imageData = tempCtx.getImageData(0, 0, canvas.width, canvas.height);
                
                // Draw boxes and RGB values for each face
                detections.forEach((detection, index) => {
                    const box = detection.box;
                    
                    // Calculate average RGB
                    const avgRGB = getAverageRGB(imageData, box.x, box.y, box.width, box.height);
                    console.log(`  Face ${index+1} RGB: R=${avgRGB.r}, G=${avgRGB.g}, B=${avgRGB.b}`);
                    
                    // Calculate brightness and compare with cutoff
                    const faceBrightness = getRGBBrightness(avgRGB);
                    const cutoffBrightness = getRGBBrightness(cutoffRGB);
                    const isDarkerThanCutoff = faceBrightness < cutoffBrightness;
                    const boxColor = isDarkerThanCutoff ? '#ff0000' : '#00ff00'; // Red if darker, green if lighter
                    
                    console.log(`  Face brightness: ${faceBrightness.toFixed(1)}, Cutoff: ${cutoffBrightness.toFixed(1)}, Box: ${isDarkerThanCutoff ? 'RED (darker)' : 'GREEN (lighter)'}`);
                    
                    // Draw white background box for visibility
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 8;
                    ctx.strokeRect(box.x - 3, box.y - 3, box.width + 6, box.height + 6);
                    
                    // Draw colored bounding box (RED or GREEN based on comparison)
                    ctx.strokeStyle = boxColor;
                    ctx.lineWidth = 5;
                    ctx.strokeRect(box.x, box.y, box.width, box.height);
                    
                    // Draw RGB label background
                    const label = `RGB(${avgRGB.r}, ${avgRGB.g}, ${avgRGB.b})`;
                    ctx.font = 'bold 16px Arial';
                    const textWidth = ctx.measureText(label).width;
                    
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    ctx.fillRect(box.x, box.y - 30, textWidth + 20, 28);
                    
                    // Draw RGB label text
                    ctx.fillStyle = 'white';
                    ctx.fillText(label, box.x + 10, box.y - 10);
                    
                    // Draw comparison indicator
                    const comparisonText = isDarkerThanCutoff ? '‚ñº DARKER' : '‚ñ≤ LIGHTER';
                    ctx.font = 'bold 12px Arial';
                    ctx.fillStyle = boxColor;
                    ctx.fillRect(box.x + box.width - 80, box.y + 5, 75, 20);
                    ctx.fillStyle = 'white';
                    ctx.fillText(comparisonText, box.x + box.width - 75, box.y + 19);
                    
                    // Draw confidence score
                    const confidence = Math.round(detection.score * 100);
                    ctx.font = 'bold 14px Arial';
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.9)';
                    ctx.fillRect(box.x, box.y + box.height + 2, 80, 24);
                    ctx.fillStyle = boxColor;
                    ctx.fillText(`${confidence}%`, box.x + 10, box.y + box.height + 18);
                    
                    // Draw colored square showing the average color
                    const squareSize = 30;
                    ctx.fillStyle = `rgb(${avgRGB.r}, ${avgRGB.g}, ${avgRGB.b})`;
                    ctx.fillRect(box.x + 5, box.y + 5, squareSize, squareSize);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(box.x + 5, box.y + 5, squareSize, squareSize);
                });
                
                if (detections.length > 0) {
                    status.innerHTML = `<span style="color: #00ff00; font-weight: bold;">‚úì Tracking ${detections.length} face${detections.length > 1 ? 's' : ''}</span>`;
                } else {
                    status.textContent = 'No faces detected. Move closer, improve lighting, or increase sensitivity.';
                }
                
            } catch (error) {
                console.error('‚ùå Detection error:', error);
                status.textContent = 'Detection error - check console for details';
            }
            
            // Continue detection
            requestAnimationFrame(detectFaces);
        }

        // Event listeners
        startBtn.addEventListener('click', startCamera);
        stopBtn.addEventListener('click', stopCamera);

        // Load models on page load
        loadModels();
    </script>
</body>
</html>